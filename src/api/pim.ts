import { AccountInfoOrId, EligibleRole } from '@/model/EligibleRole'
import {
	AuthorizationManagementClient,
	RoleAssignmentScheduleInstance,
	RoleAssignmentScheduleRequest,
	RoleEligibilityScheduleInstance,
} from '@azure/arm-authorization'
import { AccountInfo } from '@azure/msal-browser'
import { match } from 'ts-pattern'
import { AccountInfoHomeId, AccountInfoTokenCredential, AccountInfoUniqueId, getAccountByLocalId } from './auth'
import { throwError } from './util'

// Scoping to subscription is not needed for the client as we will do it in our requests
const UNSPECIFIED_SUBSCRIPTION_ID = '00000000-0000-0000-0000-000000000000'
/** This is needed for every query or higher privileges are required */
const MY_ROLES_ONLY = 'asTarget()'
const pimClients: Map<AccountInfoHomeId, AuthorizationManagementClient> = new Map()

/**
 * Returns a singleton AuthorizationManagementClient for the app per best practice
 * @param account The account info.
 */
function getPimClient(account: AccountInfo | AccountInfoUniqueId) {
	const localId = typeof account === 'string' ? account : account.localAccountId
	let client: AuthorizationManagementClient | undefined = pimClients.get(localId)
	if (!client) {
		const account = getAccountByLocalId(localId)
		const tokenCredential = new AccountInfoTokenCredential(account)
		client = new AuthorizationManagementClient(tokenCredential, UNSPECIFIED_SUBSCRIPTION_ID)
		pimClients.set(localId, client)
	}
	return client
}

export async function getRoleManagementPolicyAssignments(
	account: AccountInfo,
	schedule: RoleEligibilityScheduleInstance,
) {
	try {
		if (!schedule.scope || !schedule.roleDefinitionId) {
			throw new Error('Schedule is missing scope or roleDefinitionId')
		}

		const pimClient = getPimClient(account)

		// The policy assignment is linked to the role definition and scope
		const policyAssignments = await pimClient.roleManagementPolicyAssignments.listForScope(schedule.scope)

		// Filter on the client side to get assignments for this role definition
		for await (const assignment of policyAssignments) {
			if (assignment.roleDefinitionId === schedule.roleDefinitionId) {
				console.debug(`Fetched Policy Assignment: ${assignment.id}`)

				// Get the policy details
				if (assignment.policyId) {
					try {
						const policy = await pimClient.roleManagementPolicies.get(schedule.scope, assignment.policyId)
						return {
							assignment,
							policy,
						}
					} catch (policyError) {
						console.error('Error fetching policy details:', policyError)
						return { assignment }
					}
				}

				return { assignment }
			}
		}

		throw new Error('No policy assignments found')
	} catch (err) {
		console.error('Error in getRoleManagementPolicyAssignments:', err)
		throw err
	}
}

export async function getPolicyRequirements(_account: AccountInfo, _schedule: RoleEligibilityScheduleInstance) {
	// FIXME: Implement policy requirement fetching logic
	return {
		requiresJustification: true,
		requiresTicket: false,
		maxDuration: 'PT24H', // Default 1 day
	}
}

/**
 * Gets the status of a role eligibility schedule request.
 * @param account The account info.
 * @param requestId The ID of the RoleAssignmentScheduleRequest.
 */
export async function getRoleAssignmentScheduleRequest(
	account: AccountInfo,
	requestId: RoleAssignmentScheduleRequestId,
) {
	const lastSlash = requestId.lastIndexOf('/')
	const scope = requestId.substring(0, lastSlash)
	const id = requestId.substring(lastSlash + 1)

	return getPimClient(account).roleAssignmentScheduleRequests.get(scope, id)
}

/** Adjusts the autogenerated type to require what is needed for a eligible role activation */
export interface EligibleRoleActivationRequest extends RoleAssignmentScheduleRequest {
	id: string
	scope: string
	principalId: string
	requestType: 'SelfActivate'
	roleDefinitionId: string
	linkedRoleEligibilityScheduleId: string
}

import {
	CommonRoleActivateRequest,
	toArmRoleAssignmentScheduleRequest,
	toEntraRoleAssignmentScheduleRequest,
	toGroupRoleAssignmentScheduleRequest,
} from '@/model/CommonRoleActivateRequest'
import {
	fromArmAssignment,
	fromGraphAssignment,
	fromGroupAssignment,
} from '@/model/CommonRoleAssignmentScheduleInstance'
import {
	createEntraGroupAssignmentScheduleRequest,
	createEntraRoleAssignmentScheduleRequest,
	deactivateEntraGroupAssignmentScheduleRequest,
	deactivateEntraRoleAssignmentScheduleRequest,
} from './pimGraph'

export async function activateEligibleRole(account: AccountInfo, request: CommonRoleActivateRequest) {
	return await match(request)
		// ARM-based role activation (Azure Resource roles)
		.with({ sourceType: 'arm' }, async req => {
			const result = await getPimClient(account).roleAssignmentScheduleRequests.create(
				req.scope,
				req.id,
				toArmRoleAssignmentScheduleRequest(req),
			)
			if (!result) {
				throw new Error('Activating Role completed but no object was returned. This is a bug.')
			}
			return fromArmAssignment(result)
		})
		// Entra ID directory role activation
		.with({ sourceType: 'graph' }, async req => {
			const result = await createEntraRoleAssignmentScheduleRequest(account, toEntraRoleAssignmentScheduleRequest(req))
			if (!result) {
				throw new Error('Activating Role completed but no object was returned. This is a bug.')
			}
			return fromGraphAssignment({
				id: result.id!,
				principalId: result.principalId!,
				roleDefinitionId: result.roleDefinitionId!,
			})
		})
		// Group role activation
		.with({ sourceType: 'group' }, async req => {
			const result = await createEntraGroupAssignmentScheduleRequest(account, toGroupRoleAssignmentScheduleRequest(req))
			if (!result) {
				throw new Error('Activating Role completed but no object was returned. This is a bug.')
			}
			return fromGroupAssignment({
				id: result.id!,
				principalId: result.principalId!,
				groupId: result.groupId!,
				accessId: result.accessId!,
			})
		})
		.otherwise(() => {
			throw new Error('Invalid activation request type')
		})
}

export async function deactivateEligibleRole(eligibleRole: EligibleRole) {
	const { accountId, schedule } = eligibleRole
	const client = getPimClient(accountId)

	// For ARM-based schedules, we need the original schedule
	if (schedule.sourceType === 'arm' && schedule.originalSchedule) {
		const armSchedule = schedule.originalSchedule as RoleEligibilityScheduleInstance
		if (!armSchedule.scope) throwError('scope doesnt exist')
		if (!armSchedule.id) throwError('id doesnt exist')
		return await client.roleAssignmentScheduleRequests.create(armSchedule.scope, crypto.randomUUID(), {
			requestType: 'SelfDeactivate',
			principalId: accountId,
			roleDefinitionId: armSchedule.roleDefinitionId,
		})
	} else if (schedule.sourceType === 'graph' && schedule.originalSchedule) {
		// Entra ID directory role deactivation
		return await deactivateEntraRoleAssignmentScheduleRequest(eligibleRole)
	} else if (schedule.sourceType === 'group' && schedule.originalSchedule) {
		// Group role deactivation
		return await deactivateEntraGroupAssignmentScheduleRequest(eligibleRole)
	} else {
		const roleType =
			schedule.sourceType === 'graph' ? 'Entra ID' : schedule.sourceType === 'group' ? 'Group' : 'Non-ARM'
		throw new Error(`${roleType} role deactivation is not yet implemented`)
	}
}

/** Check a role status by fetching its request and seeing if it links back to the schedule */
export async function getEligibleRoleAssignment(eligibleRole: EligibleRole) {
	const { accountId, schedule } = eligibleRole
	const client = getPimClient(accountId)

	// For ARM-based schedules, we need the original schedule
	if (schedule.sourceType === 'arm' && schedule.originalSchedule) {
		const armSchedule = schedule.originalSchedule as RoleEligibilityScheduleInstance
		const scopedAssignments = client.roleAssignmentScheduleInstances.listForScope(
			armSchedule.scope ?? throwError('Missing schedule scope'),
			{ filter: MY_ROLES_ONLY },
		)
		for await (const assignment of scopedAssignments) {
			if (assignment.linkedRoleEligibilityScheduleInstanceId === armSchedule.id) {
				return assignment
			}
		}
	} else {
		// For Graph-based and Group-based schedules, we need to implement the respective API assignment lookup
		const roleType =
			schedule.sourceType === 'graph' ? 'Entra ID' : schedule.sourceType === 'group' ? 'Group' : 'Non-ARM'
		throw new Error(`${roleType} role assignment lookup is not yet implemented`)
	}
}

export const getMyRoleEligibilitySchedules = (account: AccountInfoOrId, scope: string = '') =>
	getPimClient(account).roleEligibilitySchedules.listForScope(scope, { filter: MY_ROLES_ONLY })

/** Roles that can currently be activated right now */
export const getMyRoleEligibilityScheduleInstances = (account: AccountInfoOrId, scope: string = '') =>
	getPimClient(account).roleEligibilityScheduleInstances.listForScope(scope, { filter: MY_ROLES_ONLY })

/** Roles that are either eligible activated or assigned */
export const getMyRoleAssignmentScheduleInstances = (account: AccountInfoOrId, scope: string = '') =>
	getPimClient(account).roleAssignmentScheduleInstances.listForScope(scope, { filter: MY_ROLES_ONLY })

export const getMyRoleAssignmentScheduleRequests = (account: AccountInfoOrId, scope: string = '') =>
	getPimClient(account).roleAssignmentScheduleRequests.listForScope(scope, { filter: MY_ROLES_ONLY })

export const filterActivatedRoles = (assignment: RoleAssignmentScheduleInstance[]) =>
	assignment.filter(assignment => assignment.assignmentType === 'Activated')

// These types are useful for uniquely identifying these items without using their objects
export type RoleAssignmentScheduleRequestId = NonNullable<RoleAssignmentScheduleRequest['id']>
export type RoleEligibilityScheduleInstanceId = NonNullable<RoleEligibilityScheduleInstance['id']>
